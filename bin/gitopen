#!/usr/bin/env node

var commander = require('commander');
var fs = require('fs');
var path = require('path');
var child_process = require('child_process');
var gitRemote = require('../');

commander
  .version(require('../package.json').version)
  .option('-p, --path <path>', 'CWD path')
  .option('-b, --branch <branch-name>', 'Goto branch in browser')
  .option('-r, --remote <remote-name>', 'Goto remote in browser')
  .option('-v, --verbose', 'Print verbose information.')
  .parse(process.argv);

var RE_ISSUE_ID = /^#\d+$/;
var RE_BRANCH_COMPARE = /^(\w+)?:(\w+)?$/;

var category = commander.args[0];
var cwd = commander.path || process.cwd();
var remoteName = commander.remote || 'origin';
var branch = '';
var subpath = '';
var match;

function getCurrentBranch(cwd) {
  return child_process.execSync('git symbolic-ref --short HEAD', {cwd: cwd})
          .toString().trim();
}

switch(category){
case 'issue':
case 'issues':
  subpath = '/issues';
  if (commander.args[1] === 'new') {
    subpath += '/new';
  }
  break;
case 'pr':
case 'mr':
case 'pull':
case 'pulls':
  subpath = '/pulls';
  if (commander.args[1] === 'new') {
    subpath = '/compare';
  } else if (match = RE_BRANCH_COMPARE.exec(commander.args[1])) {
    subpath = '/compare/' + (match[1] || 'master') + '...' + (match[2] || getCurrentBranch(cwd));
  }
  break;
case 'wiki':
case 'wikis':
  subpath = '/wiki';
  break;
case 'milestone':
case 'milestones':
  subpath = '/milestones';
  break;
case 'release':
case 'releases':
  subpath = '/releases';
  if (commander.args[1] === 'new') {
    subpath += '/new';
  }
  break;
case 'network':
  subpath = '/network';
  break;
case 'ci':
case 'commit':
case 'commits':
  subpath = '/commits';
  if (commander.branch) {
    subpath += '/' + commander.branch;
  }
  break;
case 'tag':
case 'tags':
  subpath = '/tags';
  break;
case undefined: // 未指定任何特定信息。
  break;
default:
  if (category.indexOf(':') === 0) {
    branch = category.substring(1);
  } else if (RE_ISSUE_ID.test(category)) {
    branch = '';
    subpath = '/issues/' + (category.substring(1));
  } else {
    // FILE/DIR PATH
    if (fs.existsSync(category)) {
      var stat = fs.statSync(category);
      if (stat.isFile()) {
        cwd = path.dirname(category);
        subpath = path.normalize(category);
      } else if (stat.isDirectory()) {
        cwd = category;
        subpath = category;
      }
    } else {
      console.error('Unknow category or path: ' + category);
      process.exit(1);
    }
  }
}
//if (commander.path) {
  //cwd = path.dirname(path.resolve(cwd, commander.path));
//}

var url = gitRemote({
  cwd: cwd,
  branch: commander.branch || branch,
  remote: remoteName,
  path: subpath,
});

if (commander.verbose) {
  console.log(url);
}

child_process.execSync('open ' + url);

// vim:ft=javascript
